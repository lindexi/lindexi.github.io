
# Windows 客户端软件自动更新服务的开发有哪些需求

我在团队里面也接手了 Windows 客户端软件的自动更新模块，其实这个模块是一个非常庞大的模块，我隔壁有团队在做这个事情。而我需要做的只是去接入而已，在接入的过程中，我也了解到整个自动更新机制需要涉及到的功能

<!--more-->


<!-- CreateTime:2020/11/16 9:29:18 -->

<!-- 草稿 -->

咱先从自动更新服务的地位开始聊起

## 意义

我所在的团队是做产品的，对于产品来说，整个自动更新机制就是命脉级的模块

上面这句话其实是总工大大说的。只要自动更新机制不出问题，软件部分就没有什么大不了的问题，大不了就来一个 HotFix 解决

在我加入团队这几年里面，就有很多次的事故，全部靠着软件自动更新快速发布版本解决问题。客户端软件部分，发布到用户端上，如果发现存在问题，通过自动更新，可以快速在用户端屏蔽问题

## 组成

整个自动更新服务，可以分为两大块，一部分是客户端部分，另一部分是后台部分。这里的后台指的不是后台服务器，而是整个除了客户端之外的部分。包括自动构建服务器，开发流程，测试流程，软件报备，发布控制平台，流量管控，升级监控，以及 CDN 平台等的这部分后台部分

## 稳定性

如果在团队里面定义了自动更新模块是命脉级的，意味着对自动更新模块的在客户端的最核心要求就是稳定性了

假定稳定性没有做好，例如更新效果就和微软的应用商店一样。试试想如下情况

- A: 软件出现大漏洞了，所有用户一打开软件，就会提示 林德熙是逗比 界面
- B: 没关系，赶紧开下一个版本，解决这个问题
- A: 已经开了，但是咱只有千分之一的用户能升级成功

稳定性的需求指的是在开启自动更新的时候，成功更新到新版本的成功率需要很高

此时稳定性有一些前置的要求

- 稳定的 IPC 进程间通讯机制
- 稳定的进程本身
- 可被监控

这些前置的要求的原因分别如下：

要求稳定的 IPC 进程间通讯机制是在于当更新模块和业务应用是拆分为多个进程的时候，如何让业务应用通知更新模块所在的进程进行更新，如果这个机制不够稳定，意味着由业务应用发起的更新请求这个需求在技术实现上是不稳定的

稳定的进程本身是关键，不能说更新模块所在的进程本身不断的挂掉，技术角度基于这一项考虑就有部分语言不推荐使用了

因为更新模块将会放在用户的环境上运行，而用户的环境有十分诡异的环境，也许在测试设备上完全无法了解到的环境将会有很多，因此就需要可被监控的要求，可以将运行情况以及用户环境等上报

在做稳定性的需求的时候，追求的一定不是一次性自动更新成功率，而是总体的。也就是说即使我的自动更新模块有点坑，在用户端需要进行多次的更新，最终才能成功。这个没问题，因为最终结果就是更新成功了，这就可以了。当然，如果给微软应用商店无限长的时间，也许微软的应用商店也能提升不少的成功率

在稳定性上的要求，成功更新到新版本的成功率是需要加上时间限制的，在某个时间内成功更新到新版本的成功率是多少。这个时间的定下和后台部分有所相关，这里还请忽略

成功更新到某个版本的一个前置需求就是更新不会不会进行损坏的更新，例如更新之后缺文件或文件损坏等

## 静默安装

现在大部分的软件，都默认走静默更新。是否有静默更新的需求，其实也取决与产品。但是从技术角度来说，静默更新依然是有必要的，即使产品端没这个需求。毕竟产品上如果没有未经用户同意擅自更新的需求，其实指的是大版本的软件更新而已，大多时候进行小版本的更新是有必要开静默的

什么是静默安装呢？也就是在不经用户同意的情况下，没有感知，升级到某个版本的功能

在软件自动更新的时候，最佳的方法就是不需要经过用户的交互，帮助用户升级软件。在用户下次打开的时候，就能享受到更新的版本

如上面的稳定性的追求上，如果软件支持静默安装，那么稳定性上就不需要过多追求一次性更新的成功率。一次失败了，下一次再来，毕竟对用户来说没有感知

静默安装存在的技术难度是在于文件权限问题，以及由哪个进程进行更新的问题。假定软件是安装到 Program File 文件夹里面，默认这个文件需要管理员权限才能进行写入。因此需要有一个提升权限的进程来进行自动更新的时候的写入，而假定在软件需要更新的时候这个具备权限的进程还没启动，由软件启动这个进程的时候在一些用户设备上，如开启了 UAC 限制的设备上，将会打断用户，需要用户授权才能启动

我所看到的大部分软件的自动更新的安装进程的做法，都是在新建一个服务来实现。启动系统服务的优势在于稳定性比较高，服务挂了会由系统自动启动，大部分情况下都不需要理会服务挂了的情况。同时服务具备权限，可以用来解决权限问题，在后台静默写入

而且服务是属于另一个进程，因此可以在软件还没启动，由自动更新服务进程进行文件的更改

## 下发更新

在进行软件的自动更新，有一个问题是更新的请求由谁发起的问题。假定现在有应用软件，和自动更新服务进程，那么自动更新服务进程如何知道当前需要进行软件的更新？有两个方法，第一个就是应用软件告诉自动更新服务，当前需要更新

第二个方法就是自动更新服务和后台进行通讯，了解当前是否需要更新，以及如何更新

选用第一个方法的优势在于自由和高定制性。当前我所在的集团有大量的软件，这些软件都共用相同的一个自动更新服务进程，毕竟一个软件自己带一个会让用户的设备上开启太多自动更新服务进程。此时自动更新服务的通用性就带来了功能单一的缺点了，有一些特殊的软件需要有自己的特殊规则。如果能让软件告诉自动更新服务进行更新，那么意味着自动更新的部分逻辑可以被带在应用软件中

但是第一个方法存在一个神坑就是当某个版本的软件更新完成之后，出现重大神坑，软件无法启动或执行到应用软件的自动更新逻辑时，那么自动更新服务将收不到来自应用软件的通知更新，因此应用软件将再也不能更新成功

同时第一个方法存在另一个问题就是用户端如果长时间没有打开软件，那么应用软件将会维持旧版本。这对于产品来说是不利的，在用户很久没有使用软件之后的首次使用，是属于用户召回，此时就应该给用户一个良好的体验，否则用户将可能因此而丢失。当然，更新到新版本不一定会给用户一个更好的体验哈，但是大多数的软件都会是期望给召回的用户一个新版本。例如用旧版本有一些兼容性问题，如我从 2013 之后就再也没有打开 QQ 了，而 QQ 如果也不会自动更新到新版本，那在我下次想不开打开 QQ 时用了 2013 版本的 QQ 软件…… 请问此时我对 QQ 的感觉还剩下多少？反过来呢，我打开了新版本的 QQ 一切功能就正常

第二个方法的另一个优势是可以支持紧急的软件更新，这个核心就是紧急修复问题时提供的支持。产品上，有时候会遇到一些可能被行业封杀的问题，这时候就需要有机制可以快速下架或回滚等的功能

例如产品的某个功能带了一副地图出去，然而这个地图不清真，这就玩完了。如果没有提供紧急快速下架等功能，就不好玩了哦，说不定团队明天就可以散了

这两个方法其实可以合在一起，允许后台配置下发以及软件主动请求。后台配置与软件主动请求与下文的灰发机制不冲突，详细还请看下文的灰发机制

假定团队维护的软件数量不多，那么第一个方法也可以不要

另外下发更新的后台配置下发还需要添加判断是否在当前设备上支持下发的功能，例如只给指定的某些设备下发更新某个版本等，这部分可以配合灰发使用

## 代理安装

尽管有后台可以配置下发更新，但是有时候需要做一个特殊的业务，就需要自动更新模块有代理安装的功能了。这个代理安装的工具是必须在有独立的自动更新服务的前提下才有意义的

自动更新服务是一个独立的进程，可以作为服务的形式运行，也可以作为用户进程运行。但有一点确定的，这个自动更新服务进程一定是具备高权限的进程，而且可以认为这个自动更新服务进程一定都在后台运行着

代理安装就是本地的软件通过 IPC 远程进程调用方式让自动更新服务进程协助安装某个软件。实际做法就是如本地需要去某个地方下载某个其他的软件同时安装上，但是软件本身没有具备高权限用来安装，又不期望打断用户（大部分用户都是小白，弹出 UAC 会让用户很迷）此时就需要有一个高权限的进程来协助安装。或者本地已经从其他途径获取到了安装包，但是本地软件没有权限，需要通过代理安装的方法使用自动更新服务进程协助安装

这一个功能相对来说有一些争议，这是从产品角度来说的。意味着我可以愉快通过这个功能给用户安装全家桶。咱在这里不讨论产品上以及道德上，就看自己团队的产品大佬的想法了。但是这个代理安装功能正经的使用是可以用来提升稳定性的，和优化用户体验的

这个需求更多的是技术需求而不是产品端的，意义就为了提升稳定性

用实际的例子来聊这个功能点的作用

### 切换下载源

我遇到一些用户，这些用户的网络被切到了小运营商，这些用户无法从我的 CDN 拉下任何的数据。此时我可以识别到这一点，让应用软件自动带入一个备份（当然了，这个更改是通过客服的方式给到这些用户的）可以从我的另一个备份的 CDN 进行拉取更新包

假定没有代理安装功能，那么我就需要全量更新自动更新服务，这样的做法很伤。而在有代理安装功能的辅助下，我只需要针对这部分特定的用户，在我的受影响的一个软件上（这些用户就只用我一个软件）加入备份 CDN 拉取逻辑，然后依赖代理安装的功能，从而达到不更改自动更新模块的代码，实现这部分用户的平滑修复

### 特殊网络下载配置

我遇到的另一些用户是一些有趣的学校，这部分学校有自己搭建的网络（表示我现在还无法理解具体是什么意思）而无法连接我的服务器上，在这些学校上的大流量访问需要配置一个代理到学校的一台专门的服务器才能访问，否则分分钟就将用户的电脑断网了

而我如果让我的自动更新服务模块加上配置网络代理的功能，那将会是一个神坑，将会极大降低自动更新服务模块的稳定性

但是有了代理安装的功能，就有了更好的方法。我给了这些学校的软件上加了另一个特别的进程，这个进程是专门通过配置代理去拉取更新包，将更新包下载到本地，然后调用自动更新服务的代理安装功能，安装本地的更新包，来实现自动更新的

从软件工程上，我做的是对已有的扩展，而不是更改已有的。意味着整体稳定性不会因此而下降

这个例子不是很好哈，因为我写着删除了一大部分的信息，单纯靠上面的这些信息其实有点难了解为什么选择这个方法会更好

### 内网加速下载

同样的，还是学校的网络环境，只是当前说的是大部分的学校。我是做教育应用的，会遇到有大量的在校的用户设备，在学校里面大部分的学校都有校园网，换句话说就是一个大局域网

局域网的一个大优势就是局域网快传，不用占用我服务器带宽和流量，速度有超级快

我所在的团队有另一个服务是 P2P 下载服务，这个服务刚好在有局域网的情况下能发挥出超级强力的作用。我通过在局域网内利用 P2P 服务下载到了更新包，此时使用代理安装就可以愉快的实现了利用内网进行软件的自动更新功能。而一切内网自动更新的细节，包括 P2P 本身以及安全性等，都将和自动更新服务无关，这部分逻辑拆分为两个服务和一个应用上，保持了自动更新服务的逻辑简单，从而也就让自动更新服务能做到稳定

上面说的利用内网进行自动更新是由两个服务和一个应用组成的，这里的两个服务就是 自动更新服务和 P2P 下载服务，这两个服务都是追求简单加稳定的。而一个应用就是通过调用 P2P 下载服务下载更新包，调用自动更新服务的代理安装的实际执行逻辑的应用，这个应用将会管更新包下载的版本以及安全性等问题

这里还需要回答另一个问题是如上面这样的拆分方法是否会因为服务比较多而降低总体稳定性？其实不会。因为如自动更新服务等服务的要求都是追求稳定性的，只要功能简单，逻辑简单，经过一段时间的磨合，是能将服务做的特别稳定的。而新加的特别的业务端的功能本身自己是不稳定的，如利用内网进行自动更新的功能。但这个功能调用自动更新等服务本文，调用部分以及服务都是稳定的，因此整体的不稳定仅仅只是新加的业务端功能而已，而不会因为将业务端的功能做到了服务本身而降低服务的稳定性。优先考虑扩展而不是更改逻辑

## 配置环境

自动更新时需要提供配置环境的功能，设置注册表，开启防火墙等

这部分的需求不一而足，从技术角度有两个实现方法，第一个就是更新的时候提供配置清单，由更新服务读取清单来实现功能

第二个方法就是交给应用自身，在自动更新完成之后，调用应用里面特殊的逻辑进行配置环境

在我当前的团队里面选用的上第二个方法，毕竟啥诡异的需求都有，依赖自动更新服务程序的配置是很难满足需求的。而选用第一个方法可以减少软件重复逻辑的编写，但是会带来让自动更新模块的复杂度。这和第一个需求稳定性是冲突的，可以认为想要稳定性就一定需要有足够简单的功能

从开发者的角度来说，选用配置会添加一些私有知识的学习成本，特别是存在一些不正交的配置的时候，以及存在相对路径的配置的时候，这部分配置的难度将会是比较高的，而且使用配置也不利于自动更新服务的兼容性。如依然有古老的项目使用了古老的配置方式，而自动更新服务就需要一直兼容这些古老的配置方法




## 增量更新

其实对于大土豪来说，流量是不用考虑的，带宽也是不用考虑的。因此增量更新的意义也就不大了

因此对于大土豪或者很小的用户量场景就不用考虑增量更新了

这里的增量更新也称差量更新，通过尽可能利用本地已有的信息，下载尽可能少的信息，构建出更新的版本

### 优点

因为通过差量更新的方式，可以减少下载的大小，因此有以下优点

- 减少服务器端流量或带宽的使用量
- 提升下载的速度

这里需要说明的是服务器端流量或带宽是服务器端的不同策略，假定是通过 CDN 服务的话，使用流量计费方式，意味着下载多少流量就需要给多少钱。而通过带宽计费方式意味着无论下载多少流量，计费只是算使用的值

如果用户量比较大，而且有灰发机制，同时又不是大土豪，此时选择带宽计费方式会比较省钱。哈哈，自己算一下就知道了

进行增量更新有两个方式，这两个方式不冲突，可以一起配合使用

### 文件差量更新

这是比较推荐第一步先做的，通过文件差量更新就可以减少大量的下载量了。多个版本之间，如果版本相差比较小，那么多个版本之间的差异文件一般不会很多。特别是在 dotnet core 下的独立发布的 WPF 应用，框架部分的文件在多个软件版本之间基本都是相同的

文件差量更新的做法就是仅从后台下载最新版本的差量文件，也就说从后台下载只有新版本有的问题，而新版本中如包含了当前版本已存在的文件，则不需要重复的下载

从后台下载最新版本的差量文件之后，再根据本地当前版本的文件，拼装出新版本的文件

### 二进制差量更新

而更进一步的，其实有很多的 dll 等文件，这些文件在不同版本之间的文件二进制差异很小。如果只是使用文件的差量更新，相当于对一个 dll 更改一行代码就需要整个 dll 都进行更新

采用二进制差量更新的意义就在于只从后台下载当前版本和最新版本的差量文件中，这些差量文件的二进制差异部分。采用此方法可以让发布补丁无忧，在发布补丁的时候，也许有更改几个 dll 文件，但是更改内容一定不多，此时采用二进制差异就可以极大减少下载量，提升更新速度和减少流量和带宽的使用

现在大部分的大软件，如 QQ 等，都会在自动更新的时候都会使用文件差量更新和二进制差量更新一起使用的策略。当然了，这些大厂不是为了省钱，只是为了提升用户端的下载速度而已。可以想象在更新了一个版本的时候，其实用户端更新的数据量其实就和这两个版本之前添加的代码量和资源差不多，这个速度是十分快的，特别是带足了依赖的时候



## 后台


## 灰度发布


## 参考

[PC客户端软件升级方式简史_danxuezx的专栏-CSDN博客](https://blog.csdn.net/danxuezx/article/details/83784318 )

[windows下关于程序的自动更新方案_她的吻让他-CSDN博客_windows程序自动升级方案](https://blog.csdn.net/qq_37059136/article/details/82377786 )





<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](http://blog.csdn.net/lindexi_gd)(包含链接:http://blog.csdn.net/lindexi_gd )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。