
# Windows 客户端软件自动更新服务的开发有哪些需求

我在团队里面也接手了 Windows 客户端软件的自动更新模块，其实这个模块是一个非常庞大的模块，我隔壁有团队在做这个事情。而我需要做的只是去接入而已，在接入的过程中，我也了解到整个自动更新机制需要涉及到的功能

<!--more-->


<!-- CreateTime:2020/11/16 9:29:18 -->

<!-- 草稿 -->

咱先从自动更新服务的地位开始聊起

## 意义

我所在的团队是做产品的，对于产品来说，整个自动更新机制就是命脉级的模块

上面这句话其实是总工大大说的。只要自动更新机制不出问题，软件部分就没有什么大不了的问题，大不了就来一个 HotFix 解决

在我加入团队这几年里面，就有很多次的事故，全部靠着软件自动更新快速发布版本解决问题。客户端软件部分，发布到用户端上，如果发现存在问题，通过自动更新，可以快速在用户端屏蔽问题

## 组成

整个自动更新服务，可以分为两大块，一部分是客户端部分，另一部分是后台部分。这里的后台指的不是后台服务器，而是整个除了客户端之外的部分。包括自动构建服务器，开发流程，测试流程，软件报备，发布控制平台，流量管控，升级监控，以及 CDN 平台等的这部分后台部分

## 稳定性

如果在团队里面定义了自动更新模块是命脉级的，意味着对自动更新模块的在客户端的最核心要求就是稳定性了

假定稳定性没有做好，例如更新效果就和微软的应用商店一样。试试想如下情况

- A: 软件出现大漏洞了，所有用户一打开软件，就会提示 林德熙是逗比 界面
- B: 没关系，赶紧开下一个版本，解决这个问题
- A: 已经开了，但是咱只有千分之一的用户能升级成功

稳定性的需求指的是在开启自动更新的时候，成功更新到新版本的成功率需要很高

在做稳定性的需求的时候，追求的一定不是一次性自动更新成功率，而是总体的。也就是说即使我的自动更新模块有点坑，在用户端需要进行多次的更新，最终才能成功。这个没问题，因为最终结果就是更新成功了，这就可以了。当然，如果给微软应用商店无限长的时间，也许微软的应用商店也能提升不少的成功率

在稳定性上的要求，成功更新到新版本的成功率是需要加上时间限制的，在某个时间内成功更新到新版本的成功率是多少。这个时间的定下和后台部分有所相关，这里还请忽略

成功更新到某个版本的一个前置需求就是更新不会不会进行损坏的更新，例如更新之后缺文件或文件损坏等

## 静默安装

现在大部分的软件，都默认走静默更新。是否有静默更新的需求，其实也取决与产品。但是从技术角度来说，静默更新依然是有必要的，即使产品端没这个需求。毕竟产品上如果没有未经用户同意擅自更新的需求，其实指的是大版本的软件更新而已，大多时候进行小版本的更新是有必要开静默的

什么是静默安装呢？也就是在不经用户同意的情况下，没有感知，升级到某个版本的功能

在软件自动更新的时候，最佳的方法就是不需要经过用户的交互，帮助用户升级软件。在用户下次打开的时候，就能享受到更新的版本

如上面的稳定性的追求上，如果软件支持静默安装，那么稳定性上就不需要过多追求一次性更新的成功率。一次失败了，下一次再来，毕竟对用户来说没有感知

静默安装存在的技术难度是在于文件权限问题，以及由哪个进程进行更新的问题。假定软件是安装到 Program File 文件夹里面，默认这个文件需要管理员权限才能进行写入。因此需要有一个提升权限的进程来进行自动更新的时候的写入，而假定在软件需要更新的时候这个具备权限的进程还没启动，由软件启动这个进程的时候在一些用户设备上，如开启了 UAC 限制的设备上，将会打断用户，需要用户授权才能启动

我所看到的大部分软件的自动更新的安装进程的做法，都是在新建一个服务来实现。启动系统服务的优势在于稳定性比较高，服务挂了会由系统自动启动，大部分情况下都不需要理会服务挂了的情况。同时服务具备权限，可以用来解决权限问题，在后台静默写入

而且服务是属于另一个进程，因此可以在软件还没启动，由自动更新服务进程进行文件的更改

## 下发更新

在进行软件的自动更新，有一个问题是更新的请求由谁发起的问题。假定现在有应用软件，和自动更新服务进程，那么自动更新服务进程如何知道当前需要进行软件的更新？有两个方法，第一个就是应用软件告诉自动更新服务，当前需要更新

第二个方法就是自动更新服务和后台进行通讯，了解当前是否需要更新，以及如何更新

选用第一个方法的优势在于自由和高定制性。当前我所在的集团有大量的软件，这些软件都共用相同的一个自动更新服务进程，毕竟一个软件自己带一个会让用户的设备上开启太多自动更新服务进程。此时自动更新服务的通用性就带来了功能单一的缺点了，有一些特殊的软件需要有自己的特殊规则。如果能让软件告诉自动更新服务进行更新，那么意味着自动更新的部分逻辑可以被带在应用软件中

但是第一个方法存在一个神坑就是当某个版本的软件更新完成之后，出现重大神坑，软件无法启动或执行到应用软件的自动更新逻辑时，那么自动更新服务将收不到来自应用软件的通知更新，因此应用软件将再也不能更新成功

同时第一个方法存在另一个问题就是用户端如果长时间没有打开软件，那么应用软件将会维持旧版本。这对于产品来说是不利的，在用户很久没有使用软件之后的首次使用，是属于用户召回，此时就应该给用户一个良好的体验，否则用户将可能因此而丢失。当然，更新到新版本不一定会给用户一个更好的体验哈，但是大多数的软件都会是期望给召回的用户一个新版本。例如用旧版本有一些兼容性问题，如我从 2013 之后就再也没有打开 QQ 了，而 QQ 如果也不会自动更新到新版本，那在我下次想不开打开 QQ 时用了 2013 版本的 QQ 软件…… 请问此时我对 QQ 的感觉还剩下多少？反过来呢，我打开了新版本的 QQ 一切功能就正常

第二个方法的另一个优势是可以支持紧急的软件更新，这个核心就是紧急修复问题时提供的支持。产品上，有时候会遇到一些可能被行业封杀的问题，这时候就需要有机制可以快速下架或回滚等的功能

这两个方法其实可以合在一起，假定团队维护的软件数量不多，那么第一个方法也可以不要

## 配置环境

自动更新时需要提供配置环境的功能，设置注册表，开启防火墙等

这部分的需求不一而足，从技术角度有两个实现方法，第一个就是更新的时候提供配置清单，由更新服务读取清单来实现功能

第二个方法就是交给应用自身，在自动更新完成之后，调用应用里面特殊的逻辑进行配置环境

在我当前的团队里面选用的上第二个方法，比较啥诡异的需求都有。而选用第一个方法可以减少软件重复逻辑的编写，但是会带来让自动更新模块的复杂度。这和第一个需求稳定性是冲突的，可以认为想要稳定性就一定需要有足够简单的功能





<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](http://blog.csdn.net/lindexi_gd)(包含链接:http://blog.csdn.net/lindexi_gd )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。