# 沙堆模型

本文告诉大家一个简单的模型，这个模型是用来说明在一个大的团队，如何才能有效让团队组成在添加成员时，总体降低。

<!--more-->
<!-- csdn -->
<div id="toc"></div>


这个模型是我从逻辑里面看到，在复杂的组合，可能因为一个新的成员加入，让整个团队开始变成负面

本文里面存在大量的计算，虽然我尽量把文章写的很简单，但是这个算法本身不是那么好理解。最关键的就在于算法本身，请不要问我为什么这个算法需要这样算，因为都是我定义的。

## 正面属性负面属性

对于任意的属性，都可以作为正面和负面表示。

数学本身是没有意义，给数学现实的计算才有意义，为了让大家能够简单的看懂，我把下面的算法用写游戏的方式告诉大家。

很久之前，听了研究院的院长说，人工智能就是一个炼药的过程，放入一些数据，然后等，最后会发生什么是没人知道。

所以我也就把下面这个游戏叫做炼药师。

对于炼药师，他需要了解很多的材料，每个材料都有正面属性和负面属性。

如材料1 正面属性是 增加生命力，负面属性是降低魔力。

材料2 正面属性是 增加魔力，负面属性是降低力量。

## 材料相加

这里需要重新定义加法，两个材料相加会变成新的材料。

两个相加的材料的最终效果是正面属性相加、负面属性相加。如果正面属性或负面属性有相同的作用，那么两个相同的作用就可以使用数值的加法相加。

如下面的两个材料

材料 1

```csharp
正面属性

生命力 1.0

负面属性

魔力 2.1
```

材料 2

```csharp
正面属性

魔力 2.2

负面属性

力量 0.1
```

那么材料1+材料2的第一步计算请看下面


材料1 的正面属性和材料2的正面属性相加，如果有相同的效果，把相同效果进行数值相加。材料1的负面属性和材料2相加，和正面属性相加的计算方式相同。

材料1+材料2

```csharp
正面属性

生命力 1.0

魔力 2.2 

负面属性

魔力 2.1

力量 0.1
```

第二步计算是找到正面属性和负面属性同时存在的效果，使用正面属性的效果的值减去负面属性的效果。然后去掉负面属性中和正面属性相同的效果。

从 材料1+材料2 的上一步，可以找到存在正面属性的 魔力值和负面属性的魔力值，把两个值相减。从负面属性去掉魔力

这时计算材料1+材料2的魔力值 2.2-2.1=0.1，最后计算出来材料1+材料2的材料3

材料3


> 正面属性
> 生命力 1.0
> 魔力 2.2-2.1=0.1 
> 负面属性
> ~~魔力 2.1~~
> 力量 0.1

## 交换率

对于材料的加法，是符合交换率，材料a和材料b和材料c的加法

```csharp
a+b+c=a+c+b
```

两个材料相加，返回的是新材料，所以可以和其他材料相加。

```csharp
a+b+c=(a+b)+c
```

现在还需要做一些定义，一个材料只有正面属性生效。材料的负面属性只是在遇到另一个材料，而且刚好这个材料的正面属性存在属性和他的负面属性相同，才会把负面属性拿出来让材料的正面属性减去。

从上面的定义可以推出，任何的材料不会同时有一个属性存在正面属性集合和负面属性集合。

一个材料的正面属性集合可以有很多个属性值。

材料的正面属性集合的属性的属性值可能是负数。如两个材料相加，材料1的正面属性刚好和材料2的负面属性相同，而且材料1的属性值很小，这时两个材料相加，新的材料就会出现一个属性值为负数。

对于一个材料的负面属性值是否一定要求是正数还没定义，但是从炼药师的题目，是不能存在负数的。因为负面的属性是不会生效，那么如果一个负面属性值是负数，在一个材料的正面属性和这个材料的负面属性相同，反而会加大材料的正面属性值。

## 代码

现在还看不错来这个模型的意义，需要来写一点代码让大家比较容易看。

```csharp
    class 材料
    {
        public List<属性> 正面List { set; get; }=new List<属性>();
        public List<属性> 反向List { set; get; }=new List<属性>();
    }

    class 属性
    {
        public string 属性名 { get; set; }

        public double 属性值 { get; set; }
    }
```

代码定义很简单，因为我把变量都写中文，这样即使不会 C# 也大概可以看懂。

然后重新重写加法计算

```csharp
        public static 材料 Add(材料 材料1, 材料 材料2)
        {
            var 材料3 = new 材料();
            材料3.正面List.AddRange(材料1.正面List);
            材料3.正面List.AddRange(材料2.正面List);

            材料3.反向List.AddRange(材料1.反向List);
            材料3.反向List.AddRange(材料2.反向List);

            foreach (var 属性 in 材料3.正面List)
            {
                var temp = 材料3.反向List.Find(t => t.属性名 == 属性.属性名);
                if (temp != null)
                {
                    属性.属性值 -= temp.属性值;
                    材料3.反向List.Remove(temp);
                }
            }

            return 材料3;
        }

```

现在来把上面的测试写一下

```csharp
          var 材料1 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("生命力", 1.0)
                },
                反向List = new List<属性>()
                {
                    new 属性("魔力", 2.1)
                }
            };

            var 材料2 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("魔力", 2.2)
                },
                反向List = new List<属性>()
                {
                    new 属性("力量", 0.1)
                }
            };
```

因为需要输出一下值，所以再写一些代码

```csharp
      public override string ToString()
        {
            var str = new StringBuilder();
            str.Append("正面属性\r\n");

            foreach (var temp in 正面List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            str.Append("负面属性\r\n");

            foreach (var temp in 反向List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            return str.ToString();
        }
```

现在尝试调用添加两个材料，然后看一下输出

```csharp
            var 材料3 = 材料.Add(材料1, 材料2);

            Console.WriteLine("材料3");

            Console.WriteLine(材料3.ToString());
```

运行代码，可以看到输出

```csharp
材料3
正面属性
生命力 1.00
魔力 0.10
负面属性
力量 0.10

```

和刚才的计算的值一样。

## 定义属性

刚才的属性还不够多，在属性足够多的时候才可以进行这个计算。

从我的其他游戏复制过来一些属性

```csharp
生命值
最大生命值
生命值恢复
魔力值
最大魔力值
魔力值恢复
精力
最大精力
精力恢复
怒气
最大怒气
根骨
力量
敏捷
智力
修为
格挡
破盾
物理攻击
法术攻击
物理防御
法术防御
法术躲避
物理躲避
物理命中
法术命中
```

创建一个随机的函数用来创建随机的属性

```csharp
       private static 属性 LeadayrirreeCearwateje()
        {
            var keraigarVunimaw = _biheljisTebalpur[_ran.Next(_biheljisTebalpur.Length)];

            var safajallBairlouci = ((double) _ran.Next(100)) / 10;


            return new 属性(keraigarVunimaw, safajallBairlouci);
        }

        private static Random _ran = new Random();

        private static string[] _biheljisTebalpur = new[]
        {
            "生命值", "最大生命值", "生命值恢复", "魔力值", "最大魔力值", "魔力值恢复", "精力", "最大精力", "精力恢复", "怒气", "最大怒气", "根骨", "力量", "敏捷",
            "智力", "修为", "格挡", "破盾", "物理攻击", "法术攻击", "物理防御", "法术防御", "法术躲避", "物理躲避", "物理命中", "法术命中",
        };
```

为了测试这个值，循环 10 次然后输出

```csharp
最大魔力值 0.10

最大魔力值 4.90

生命值 5.60

物理躲避 4.60

法术攻击 7.40

精力 3.50

物理命中 4.30

物理攻击 5.20

最大魔力值 8.40

精力恢复 9.20
```

## 定义材料

在定义材料的时候，因为代码比较多，所以先给大家看一下现在的材料类

```csharp
    class 材料
    {
        public List<属性> 正面List { set; get; } = new List<属性>();
        public List<属性> 反向List { set; get; } = new List<属性>();


        public static 材料 Add(材料 材料1, 材料 材料2)
        {
            var 材料3 = new 材料();
            材料3.正面List.AddRange(材料1.正面List);
            材料3.正面List.AddRange(材料2.正面List);

            材料3.反向List.AddRange(材料1.反向List);
            材料3.反向List.AddRange(材料2.反向List);

            材料3.TasaGicurlanair();

            return 材料3;
        }

        public 材料 TasaGicurlanair()
        {
            foreach (var 属性 in 正面List)
            {
                var temp = 反向List.Find(t => t.属性名 == 属性.属性名);
                if (temp != null)
                {
                    属性.属性值 -= temp.属性值;
                    反向List.Remove(temp);
                }
            }

            return this;
        }

        public override string ToString()
        {
            var str = new StringBuilder();
            str.Append("正面属性\r\n");

            foreach (var temp in 正面List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            str.Append("负面属性\r\n");

            foreach (var temp in 反向List)
            {
                str.Append(temp.属性名 + " " + temp.属性值.ToString("0.00") + "\r\n");
            }

            return str.ToString();
        }
    }

```

现在写一个创建随机的材料

```csharp
    class PeltooDerrer
    {
        public static 材料 TishishesiFaisearcaserewaw(int 正面属性数量, int 反向属性数量)
        {
            var rawxouFedi = new List<属性>(正面属性数量);
            var sounisaCuverchaybi = new List<属性>(反向属性数量);

            for (int i = 0; i < 正面属性数量; i++)
            {
                rawxouFedi.Add(LeadayrirreeCearwateje());
            }

            for (int i = 0; i < 反向属性数量; i++)
            {
                sounisaCuverchaybi.Add(LeadayrirreeCearwateje());
            }

            return new 材料()
            {
                正面List = rawxouFedi,
                反向List = sounisaCuverchaybi
            }.TasaGicurlanair();
        }

        public static 属性 LeadayrirreeCearwateje()
        {
            var keraigarVunimaw = _biheljisTebalpur[_ran.Next(_biheljisTebalpur.Length)];

            var safajallBairlouci = ((double) _ran.Next(100)) / 10;

            return new 属性(keraigarVunimaw, safajallBairlouci);
        }

        private static Random _ran = new Random();

        private static string[] _biheljisTebalpur = new[]
        {
            "生命值", "最大生命值", "生命值恢复", "魔力值", "最大魔力值", "魔力值恢复", "精力", "最大精力", "精力恢复", "怒气", "最大怒气", "根骨", "力量", "敏捷",
            "智力", "修为", "格挡", "破盾", "物理攻击", "法术攻击", "物理防御", "法术防御", "法术躲避", "物理躲避", "物理命中", "法术命中",
        };
    }

```

因为随机的属性可能重复，所以需要修改刚才的材料类，让他去掉相同的属性，如果存在相同的属性，就先把相同属性相加

```csharp
    public 材料 TasaGicurlanair()
        {
            正面List = KayveDurchoo(正面List);
            反向List = KayveDurchoo(反向List);

            foreach (var 属性 in 正面List)
            {
                var temp = 反向List.Find(t => t.属性名 == 属性.属性名);
                if (temp != null)
                {
                    属性.属性值 -= temp.属性值;
                    反向List.Remove(temp);
                }
            }

            return this;
        }

        private static List<属性> KayveDurchoo(List<属性> gasmerCalor)
        {
            for (var i = 0; i < gasmerCalor.Count; i++)
            {
                for (var j = i+1; j < gasmerCalor.Count; j++)
                {
                    if (gasmerCalor[i].属性名 == gasmerCalor[j].属性名)
                    {
                        gasmerCalor[i].属性值 += gasmerCalor[j].属性值;

                        gasmerCalor.RemoveAt(j);

                        j--;
                    }
                }
            }

            return gasmerCalor;
        }
```

测试一下创建的材料是否是符合预期

```csharp
        private static void HalwhooSairkall()
        {
            var tishishesiFaisearcaserewaw = PeltooDerrer.TishishesiFaisearcaserewaw(2, 5);

            Console.WriteLine(tishishesiFaisearcaserewaw.ToString());
        }
```

现在基础的代码就已经创建好了，可以进行模型计算

## 测试

需要知道，测试只是说明在这个模型通过很多随机的计算会算出什么，测试本身不说明什么。在数学没有和现实相关，数学没意义，之后给了现实的计算才可以知道算出来的是什么。

因为现在很难衡量一个材料的好或不好，但是我可以通过属性值是否都是负数知道一个材料是不好的材料。

在属性的值都是 [0-10] ，正面属性有2个，负面属性有5个，很不出意外，在足够多次的添加之后，得到的是正面属性包含全部的属性，而且全部都是负数。

```csharp
      private static void CapalSawnerno()
        {
            var 材料1 = PeltooDerrer.TishishesiFaisearcaserewaw(2, 5);
            Console.WriteLine(材料1.ToString());
            while (true)
            {
                Console.Read();

                Console.Clear();

                var 材料2 = PeltooDerrer.TishishesiFaisearcaserewaw(2, 5);
                Console.WriteLine("材料2");
                Console.WriteLine(材料2.ToString());

                Console.WriteLine();

                Console.WriteLine("材料相加");

                材料1 = 材料.Add(材料1, 材料2);

                Console.WriteLine(材料1.ToString());
            }
        }
```

调用这个方法，只需要不停按回车就可以看到每次的值。

因为属性的概率和值概率相同，在负面属性的数量大于正面属性的数量，那么很容易计算出来，在材料越多的时候，总的值是负数的概率越大。

在使用足够多的材料相加的时候，可以找到一个材料，包含了定义的所有属性，而且全部的值都是负数。

虽然已经知道了答案，但是他的随机计算概率还是需要看一下。

```csharp
        private static void NairduSowmeame()
        {
            var 材料1 = PeltooDerrer.TishishesiFaisearcaserewaw(2, 5);
            for (int i = 0; i < 1000; i++)
            {
                var 材料2 = PeltooDerrer.TishishesiFaisearcaserewaw(2, 5);
                材料1 = 材料.Add(材料1, 材料2);

                if (i % 10 == 0)
                {
                    Console.WriteLine("经过第"+i+"次计算");
                    Console.WriteLine("材料存在"+ 材料1.正面List.Count+"个正面属性");
                    var basitorLorgal = 材料1.正面List.Count(temp => temp.属性值 < 0);
                    Console.WriteLine("其中属性为负数有"+ basitorLorgal+" 占"+((double)basitorLorgal / 材料1.正面List.Count).ToString("0.00"));

                    Console.WriteLine();
                }
            }
        }
```

可以看到下面的输出

```csharp
经过第0次计算
材料存在4个正面属性
其中属性为负数有0 占0.00

经过第10次计算
材料存在15个正面属性
其中属性为负数有8 占0.53

经过第20次计算
材料存在23个正面属性
其中属性为负数有19 占0.83

经过第30次计算
材料存在24个正面属性
其中属性为负数有19 占0.79

经过第40次计算
材料存在25个正面属性
其中属性为负数有21 占0.84

经过第50次计算
材料存在26个正面属性
其中属性为负数有23 占0.88

经过第60次计算
材料存在26个正面属性
其中属性为负数有23 占0.88

经过第70次计算
材料存在26个正面属性
其中属性为负数有25 占0.96

经过第80次计算
材料存在26个正面属性
其中属性为负数有25 占0.96

经过第90次计算
材料存在26个正面属性
其中属性为负数有25 占0.96

经过第100次计算
材料存在26个正面属性
其中属性为负数有25 占0.96

经过第110次计算
材料存在26个正面属性
其中属性为负数有26 占1.00
```

在差不多100次的计算，就已经全部的值都是负数，在50次的计算，可以知道正面属性包含所有的属性。

因为定义的所有的属性类型就只是 26 个，在50次计算就已经有26个正面属性。

我尝试运行了3次，结果分别在80次、130次、130次，全部属性都是负数。分别在80、 130、 80次正面属性有26个，也就是包含全部的属性。

继续运行10次

```csharp
分别在34、90、24、36、52、45、41、25、39、92次包含全部属性
分别在57、29、75、103、57、104、105、52、149、76次属性都是负数
```



我开始尝试修改随机材料的正面属性和负面属性的数量，尝试使用这个方法进行计算。

```csharp
在正面属性数量3 反向属性数量5 计算100次
分别在52、65、52、48、42、43、48、58、35、66、28、54、49、48、32、51、24、58、53、72、30、125、36、60、50、47、51、49、53、44、45、72、38、50、66、40、68、59、55、43、28、43、60、29、98、30、47、71、55、80、34、61、43、46、34、61、59、37、39、36、32、38、53、43、60、38、45、81、47、53、52、52、46、53、83、38、48、46、47、28、71、52、48、56、48、47、54、54、57、62、47、36、23、42、62、32、65、45、48、43次 平均50.25包含全部属性
分别在53、66、105、41、100、79、110、118、160、24、95、123、47、70、46、49、76、93、49、138、154、89、75、83、89、146、64、53、66、177、23、97、105、83、175、58、46、76、78、52、64、47、64、111、188、81、145、104、96、70、75、126、43、96、111、73、115、161、71、59、164、86、196、93、98、33、63、86、100、74、77、141、79、43、146、85、72、262、119、84、85、90 、89、64、184、87、285、91、91、89、110、183、27、60、107、65、94、83、63、72次 平均94.51属性都是负数
```

```csharp
在正面属性数量7 反向属性数量10 计算100次
分别在55、37、33、21、36、59、26、26、59、56、42、39、74、71、61、62、45、53、34、33、96、39、34、25、31、43、81、42、33、65、38、40、55、56、36、52、72、68、49、58、42、44、21、36、62、63、32、20、91、26、43、40、65、59、44、79、56、51、41、41、72、33、67、34、32、39、30、32、67、34、24、49、57、107、28、54、34、31、42、69、42、34、53、42、30、49、35、64、28、45、32、41、30、40、59、25、25、35、37、38次 平均46.1包含全部属性
分别在54、81、122、42、110、73、94、48、169、52、110、70、129、141、75、99、157、88、108、55、179、42、103、45、83、88、72、92、108、60、147、162、63、38、169、50、107、114、293、57、55、67、69、66、77、106、90、130、65、213、97、129、99、46、65、78、35、86、84、57、93、48、121、37、163、120、138、89、64、122、71、65、59、125、121、99、86、77、53、83、115、49、83、53、88、108、65、59、80、101、51、106、58、121、102、43、86、91、79、112次 平均91.47属性都是负数
```


这时全部的属性都是按照这样随机计算出来，因为全部属性只有26个不同的，所以我就没有使用很大的数值。

现在尝试使用不同的组合，存在一部分的材料的属性数量和另一部分的材料的属性数量不同

创建两个类，表示不同的属性数量和概率

```csharp
  class DricouzallCetrorcear
    {
        public DricouzallCetrorcear(BowkeaneJanusal bowkeaneJanusal, int 概率)
        {
            BowkeaneJanusal = bowkeaneJanusal;
            this.概率 = 概率;
        }

        public BowkeaneJanusal BowkeaneJanusal { get; set; }

        public int 概率 { get; set; }
    }

    class BowkeaneJanusal
    {
        public int 正面属性数量 { get; set; }

        public int 负面属性数量 { get; set; }
    }
```

使用 DasreruhatiBassaskearcu 从指定的数组创建一个随机的材料

```csharp
     private static 材料 DasreruhatiBassaskearcu(List<DricouzallCetrorcear> surhasceeSelmir)
        {
            return MohouselCairdeeli(MireejalkasRouhihal(surhasceeSelmir));
        }

        private static 材料 MohouselCairdeeli(BowkeaneJanusal nirardearispaVimoupa)
        {
            return PeltooDerrer.TishishesiFaisearcaserewaw(nirardearispaVimoupa.正面属性数量, nirardearispaVimoupa.负面属性数量);
        }

        private static BowkeaneJanusal MireejalkasRouhihal(List<DricouzallCetrorcear> surhasceeSelmir)
        {
            var xeajurJearbar = 0;
            foreach (var temp in surhasceeSelmir)
            {
                xeajurJearbar += temp.概率;
            }

            xeajurJearbar = _ran.Next(xeajurJearbar);

            foreach (var temp in surhasceeSelmir)
            {
                xeajurJearbar -= temp.概率;
                if (xeajurJearbar < 0)
                {
                    return temp.BowkeaneJanusal;
                }
            }

            return surhasceeSelmir.Last().BowkeaneJanusal;
        }

        private static Random _ran = new Random();
```

尝试运行一下，在使用 7：3 的正面属性数量2、负面属性数量5和 正面属性数量、 负面属性数量 10 ，进行100 次计算

```csharp
        var belpeNarrou = new List<DricouzallCetrorcear>()
            {
                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 2,
                    负面属性数量 = 5
                }, 7),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 7,
                    负面属性数量 = 10,
                }, 3)
            };


            for (int i = 0; i < 100; i++)
            {
                leelerfeSerremjerepir.Add(TircheachirLetarcea(belpeNarrou));
            }
```

运行的输出是在比较少次运行就可以包含全部属性，因为存在一些材料是包含很多个属性。

```csharp
分别在18、45、36、26、14、21、20、26、20、21、23、18、43、24、35、23、28、17、31、16、27、27、22、34、42、18、17、29、45、31、34、17、29、53、21、18、24、22、56、27、15、14、15、15、28、27、25、21、24、37、42、31、41、29、22、22、40、35、19、11、14、19、29、41、29、17、29、12、43、27、31、24、43、25、31、80、49、25、22、25、26、36、39、35、33、18、44、73、25、24、22、34、27、17、29、12、21、26、23、26次 平均28.16包含全部属性
分别在64、137、85、77、59、116、236、268、126、66、87、282、110、101、69、69、181、103、87、84、69、89、136、89、184、110、144、75、112、55、154、51、109、106、171、192、122、174、118、281、106、107、155、265、54、105、93、155、69、94、76、212、47、209、194、94、91、63、125、161、183、116、161、111、293、38、183、84、171、53、205、58、163、58、72、79、104、39、82、187、132、235、68、131、138、84、55、89、76、79、119、203、98、75、136、62、154、214、81、92次 平均121.84属性都是负数
```

再修改概率进行测试

```csharp
                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 1,
                    负面属性数量 = 2
                }, 7),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 3,
                    负面属性数量 = 5,
                }, 3)
```

同样运行100次，现在在全部的属性都是负数的次数变得很大

```csharp
分别在56、55、68、65、32、81、67、102、42、91、42、40、43、56、59、40、41、66、59、50、46、29、92、55、41、36、51、41、58、49、65、65、65、36、67、48、64、48、60、54、103、52、97、52、47、104、70、84、74、35、76、40、66、47、53、44、68、62 、59、149、72、59、56、76、52、60、42、53、40、48、85、65、105、47、53、92、37、51、54、84、92、26、147、83、39、69、73 、29、53、49、72、61、85、66、81、57、33、48、38、45次 平均60.84包含全部属性
分别在208、387、194、338、413、373、186、386、718、303、214、196、196、0、146、180、160、254、173、444、339、220、190、229、157、356、384、167、92、290、243、297、234、163、424、440、138、352、321、291、315、277、174、244、167、165、286、127、224、411、554、479、470、531、400、156、290、497、208、350、192、266、290、300、419、472、553、383、195、344、435、754、270、352、466、353、219、340、265、267、261、401、235、205、202、163、637、274、197、537、179、284、315、170、491、895、409、295、330、369次 平均311.05属性都是负数
```

再次修改概率

```csharp
            var belpeNarrou = new List<DricouzallCetrorcear>()
            {
                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 1,
                    负面属性数量 = 2
                }, 6),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 3,
                    负面属性数量 = 5,
                }, 3),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 7,
                    负面属性数量 = 10,
                }, 1)
            };

```

输出很符合预期

```csharp
分别在65、40、37、49、56、40、38、54、50、27、25、49、27、44、37、28、31、42、48、37、42、100、51、35、44、48、33、27、45、22、49、26、35、26、50、68、39、34、74、43、27、35、36、43、47、67、39、27、60、36、41、46、59、48、36、25、43、37、53、28、36、43、42、39、39、46、42、41、63、35、33、45、37、40、50、19、60、27、31、68、59、64、46、25、50、32、70、39、41、40、46、36、52、49、33、71、27、51、30、48次 平均42.93包含全部属性
分别在112、176、119、476、172、193、269、142、183、179、367、634、130、108、198、140、341、499、472、270、167、161、335 、344、206、513、443、181、576、550、172、264、565、271、183、256、326、227、266、318、355、258、110、164、241、240、291、228、507、444、142、340、224、259、185、247、268、285、694、188、225、297、486、736、279、285、393、192、221、841、276、225、120、334、328、243、86、633、409、144、448、218、543、252、213、231、233、246、155、342、394、185、98、167、182、514、99、157、102、411次 平均291.17属性都是负数
```

如果输入的数量都是正面的属性数量小于负面属性的数量，那么这个测试就完成了，虽然已经知道了在足够多次数的相加，随机创建的材料都会把所有的值变为负数

现在尝试存在一些概率，正面属性的数量比较多

```csharp
          var belpeNarrou = new List<DricouzallCetrorcear>()
            {
                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 1,
                    负面属性数量 = 2
                }, 6),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 3,
                    负面属性数量 = 5,
                }, 3),

                new DricouzallCetrorcear(new BowkeaneJanusal()
                {
                    正面属性数量 = 2,
                    负面属性数量 = 1,
                }, 1)
            };
```

运行代码，可以看到输出的次数都变大，因为存在一些材料的正面数量比负面数量多，虽然数值不一样都是比较大，但是从概率上，这些材料的值可以让总的材料的全部属性变负减少。

```csharp
分别在44、38、106、61、37、51、82、32、44、52、38、35、71、71、31、118、61、59、53、68、44、48、47、38、55、64、41、48、84、35、45、60、52、59、72、64、43、55、34、54、106、70、46、61、109、55、36、52、62、26、43、65、75、74、63、52、47、55、89、45、53、69、61、37、58、46、61、40、45、79、77、25、67、76、65、46、80、46、55、55、84、33、60、40、37、57、73、45、84、49、66、32、52、50、35、39、96、59、57、73次 平均56.87包含全部属性
分别在424、393、513、283、577、141、429、250、257、545、256、222、328、328、319、402、366、221、387、349、333、429、394 、667、412、507、361、290、387、388、245、342、259、527、144、200、343、645、448、986、294、934、0、224、450、260、573、530、195、317、276、386、162、273、382、548、578、417、599、457、523、545、405、871、346、309、690、390、450、110、600、373、285、628、340、486、388、255、159、173、453、205、322、322、352、258、408、490、514、266、338、464、518、593、227、575、208、382、230、443次 平均390.46属性都是负数
```

看到这里，我还没有开始分析材料的值，可能需要一个战力计算的方法才可以知道。

很难计算材料的值是在于无法比较两个材料的大小，可能有一个材料，这个材料的正面属性很多，而且很少出现负的。这个材料虽然不错，但是如何和其他的材料放在一起，那么因为这个材料的正面属性很多，很可能就触发了其他材料的负面属性，最好加起来的值就不如原来的。

可能有一个材料的正面属性数量很少，这样这个属性和其他属性相加就不那么担心这个属性触发了其他属性的负面属性。但是可能这个材料的负面属性数量很多，和其他材料相加会被其他材料触发。

除了属性数量，还有属性的值。在很多的材料相加之后，会发现某一些负面属性的数值已经非常大，在多加了一个材料，就刚好使用了这个数值很大的负面属性，如果存在分析材料好坏的算法，那么就会发现这个材料在加了某个材料之后，总的不如之前的。

## 属性损耗

刚才的计算是材料相加时，会保留全部属性，下面再加一个规则。如果两个材料相加，会随机去掉相加之后的材料的某个属性，这个过程叫损耗。

也就是加入存在材料1和材料2，会随机去掉某个属性，这个属性可能是在正面属性可能在负面属性

材料 1

```csharp
正面属性

生命力 1.0

负面属性

魔力 2.1
```

材料 2

```csharp
正面属性

魔力 2.2

负面属性

力量 0.1
```

在相加之后的 材料3 会随机去掉某个属性，可能是正面的属性，可能是负面的属性

材料3

> 正面属性
> ~~生命力 1.0~~
> 魔力 2.2-2.1=0.1 
> 负面属性
> 力量 0.1

假设刚好材料3就被去掉了正面属性，那么材料1和材料2相加之后的还不如原来的。

修改一下代码，原来的代码不需要修改，只需要多写一个类，这个类重新写了材料相加

```csharp
  class LoukatuSeesomas
    {
        public static 材料 Add(材料 材料1, 材料 材料2)
        {
            var 材料3 = 材料.Add(材料1, 材料2);

            var tetairmeMallxayhir = 材料3.正面List.ToList();
            tetairmeMallxayhir.AddRange(材料3.反向List);

            var sasemnereJaperche = tetairmeMallxayhir[_ran.Next(tetairmeMallxayhir.Count)];

            材料3.正面List.Remove(sasemnereJaperche);
            材料3.反向List.Remove(sasemnereJaperche);

            return 材料3;
        }

        private static Random _ran = new Random();
    }
```

使用这个规则再进行测试

```csharp
        private static void NelfairbalFumearba()
        {
            var 材料1 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("生命力", 1.0)
                },
                反向List = new List<属性>()
                {
                    new 属性("魔力", 2.1)
                }
            };

            var 材料2 = new 材料()
            {
                正面List = new List<属性>()
                {
                    new 属性("魔力", 2.2)
                },
                反向List = new List<属性>()
                {
                    new 属性("力量", 0.1)
                }
            };

            Console.WriteLine(LoukatuSeesomas.Add(材料1, 材料2).ToString());
        }

```

尝试很多次运行，可以看到随机某个属性被减去。

现在的计算就不是材料的哪个属性数量多就可能计算出来什么的值。

也就是在 a+b 的结果和下一次 a+b 的结果是不能保证相同，这个计算很诡异。我就不继续进行测试

为什么我会写这样的模型，我不是在做游戏，是在看人工智能的时候，准备使用一个超实数的方法去计算，所以才提出了这个算法，我尝试使用多个方式进行计算，发现使用沙堆模型才可能做出一个有思维的人工智能。

我在很久的时间都会想超实数的计算，我学到的数学很难描述这个复杂的人工智能，所以就自己定义计算的方法。

## 人工智能

我在输入的节点 1 和节点 2 ，两个节点输出到节点 3 ，这时的 节点 3 需要拿到哪些输入

尝试使用沙堆模型，对节点3的输入就是使用沙堆模型的计算方法，节点1和节点2都是有正面属性和负面属性。