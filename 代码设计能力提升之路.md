
# 代码设计能力提升之路

代码设计能力是一个比较虚的话题，世界上也没有一个可以准确客观衡量设计能力的标准。主观来感觉，代码设计能力的强弱，对于开发者来说，还是比较重要的。有一些代码一看就觉得有设计感，无论是对在此代码基础上进行扩展开发，还是在代码内进行变更，或者是调用此代码的逻辑，都会感觉十分顺畅。但有一些代码，写之前只有神明和开发者知道，写完之后，只要神明才知道这些代码的含义
代码设计能力属于一个比较难以描述的能力。有些开发者天赋很好，刚开始接触代码就能写出富有设计感的代码。有些开发者则不然，但好在代码设计能力是一个可以通过训练获取的能力，是能够练出来的能力。我将给大家列出我所了解的代码设计能力的提升的方向和思路，期望对大家有所帮助

<!--more-->


<!-- CreateTime:2022/6/27 8:20:53 -->

<!-- 草稿 -->

## 背景

在开始之前必须说明的是，本文属于只对设计新手友好，对于刚入行或者刚接触编程的初学者来说不友好，对于行业“老司机”资深开发大佬不友好

对于刚入行或者刚接触编程的初学者，十分 **十分** 不建议阅读本文。强行按照本文的方式进行练习，只会让你的代码逻辑十分糟糕。本文所面向的设计新手指的是，了解编程语言的知识，包括基础和稍微进阶部分的知识，了解平台框架提供的能力和熟悉使用方法的开发者。如果对于语言和框架本身熟悉度不够，我十分不建议此时开始学习代码设计，核心原因在于设计出来的东西和语言框架本身提供的可能经常背道而驰，形成不良习惯

本文面向的是设计新手，将会影响本文对于很多细节逻辑的描述，这对于行业“老司机”资深开发大佬来说，也许看起来有些难受。而且设计能力是各个人都有各个人自己的特色，贸然更换自己的风格绝对不是好的事情。推荐对于大佬们来说，本文就看着玩就好了，不要受到我的影响

代码设计本身和所采用的代码语言是强关联的，那为什么网上还是流传着一些和代码语言无关的设计文章呢？这是因为只有在高度抽象的前提下，编写设计相关的文章时，才可以说设计和代码语言是分离的。但显然，这种类型的文章对于新手成长来说，要么用途不大，要么有一定的毒性。按照我的经验，基本上只有两类人群可以无视代码语言带来的差异，一种就是新手，反正无论什么代码语言，对于新手来说，都是糊糊；另一种就是比较高阶的工程师了，这种类型的高阶的工程师大概要么就是总工级或更高级的，要么就是不接触代码的高级技术经理。对于高阶的工程师来说，大部分情况下都是直接一条线一个框，划定大的体系架构，至于里面如何实现就交给手下的开发者去完善具体细节了。本文也不是面向高阶的工程师写的，高阶的工程师真要阅读本文，那我唯一的建议就是：只管大的体系建设和大的架构设计，具体技术细节交给正确的人或团队，自己只做资源的协调调度，不要外行插手内行。如果高阶的工程师不断插手具体细节工作，那大概率所做的项目要么就是要黄，要么就是在黄的边缘。基本只有两个情况下才能做好项目，第一个情况就是力大出奇迹，砸入大量人力物力和时间，最好的结果是项目勉强出来了，但团队的人留不住，所采用的设计所采用的实现充满诡异；第二个情况就是项目本身只是拿着现有的各项技术缝合出来的，没有任何核心的自主研发，堆积体力活。但在第二种情况下，这里所谓的高阶的工程师，可能只是称号是高阶的工程师，实际水平应该是没有达到的

我在进入公司的时候，当时看到了团队里面很多前辈写的库和框架，我十分眼红，因为我发现团队里面的前辈们写的代码似乎和我写的方式有着很大的差别。尽管都是使用相同的 C# 语言，还是那些基础知识，然而组织起来的代码结构就远远不是我之前能想象出来的。再加上我之前一直都有一个问题，那就是我实际工作之前，做了好几个小的项目，经常发现，写着写着我就开始写不下了，当项目稍微大到一定的规模的时候，我就发现尽管只有我一个开发者，然而我自己都会和自己冲突。项目稍微大到一定的规模的时候，我就无法把控整个项目，项目代码的走向完全都是看天的。当时我就特别想学会前辈们的这项技能，如何将库，将框架，将项目组织起来，可以容纳很多位开发者进行长时间的开发

我询问了很多位前辈，刚开始很担心的问题是，这个事情是不是很看天分。我加入公司之前，我自认自己是写了很多代码了，但为什么我就没有达到这个水平。好在经过一番了解之后，代码设计这个能力，尽管和天赋是有相关性的，但好在代码设计能力是一个可以通过训练获取的能力。前辈们当时给我和我同一届的新人的训练方法是 “多练练” 的方式，经过了好多年我回顾当时的做法，发现这确实是一个十分行之有效的方式

对于代码设计能力来说，不要想着有速成的方法。几乎任何采用速成的方式基本都是歪路。多进行刻意的训练，才能提升代码设计能力

不过回顾我自己的成长路线，我发现了当时我也走了很多奇怪的路线，我现在也带过了很多位徒弟，感觉我可以开始将这部分经验写下来，提供给大家参考。期望能让设计新手们在设计能力提升之路上能有一个方向，知道要刻意训练什么，少一点歪路

## 理清概念理清需求

为什么很多书和技术文档的一开始就是先来一个术语表以及概念介绍？这是因为在描述一个事物的时候，不同的开发者有着不同的理解。如果没有能够将描绘相同的事物下一个确切的定义，那将会导致后续的表述过程，意思被曲解。在代码设计中也是如此，如果对于相同的事物在不同的代码逻辑里面，采用的命名或者是用法都是不相同的，那自然使用方用起来就会觉得疑惑；更可怕的是将两个不相同的事物采用很是混淆的表示方式，如相同的命名表示两个容易混淆的事物，那如此实现自然是 Bug 不断，且静态代码阅读也难以了解其中的含义

明确事物的表述，建立术语表，也是属于需求分析的一个方面。试想，如果对将要开发的工作几乎没有了解，那如何着手建立术语表，如何着手开始给各个模块和各个逻辑下定义。需求分析是第一位，特别是在开始编写设计框架之前。如果期望写出来一个能好好落地的框架，那需求分析一定是第一位。需求分析过程，也是术语表建立的过程。反过来想，如果你对某个概念，和产品大佬认为的概念在理解上具有偏差，那实现的产品是不是和产品大佬给的需求也就有偏差了。在接到需求时，试试给自己强行加一个任务，就是用文字记录下来术语表，然后去问问产品大佬，是不是有哪些概念，理解不对的。有刻意去做这个事情，可以减少因为概念不相同，导致需求理解错误。但只是概念理解相同了，还只是第一步。我推荐新手在接到新需求的时候，优先考虑先不要立刻进行设计框架，如果条件允许的话，推荐先开发原型应用，通过原型应用去测试对需求的理解是否存在偏差。这里需要着重聊的一点在于，需求的理解是否存在偏差，不代表着是开发者对于产品经理的需求存在偏差，而是开发出来的产品和实际市场所需要的是否存在偏差。产品经理也是人，对于实际市场所需的需求，也不可能一定能够理解准确，而产品经理大部分都是不认错的，那锅自然就会落到开发者头上了，即便是理解对了产品经理的需求，实际开发出来的产品也有可能和实际市场上所需要的需求有偏差，导致了返工。对于框架层来说的话，因为需求而需要接近推翻重来的成本是非常高的，而且如果对于需求存在本质性的理解错误，那自然设计出来的框架，很少有不需要被推翻重来的。这就是为什么我推荐新手优先考虑先不要立刻设计框架，而是应该怎么快怎么来，先搞出来一个东西，去试试水，在搞的过程中，可以美其名叫“预研”阶段。如果条件允许，团队里面能够打成一致，那自然是能开发原型产品是最好的。所谓原型产品可以理解为一堆 Demo 级的代码，作出一个只能用来进行有限的演示的东西，实际里面的代码能够真正落到最终产品上的，那是非常少的。如果条件不允许，而且此产品需求是具备多个版本的情况下，优先第一个版本不做设计，先尝试交付出第一个版本之后，再来开始进行设计框架。通常这个时候，第一个出去的版本，也能帮助暴露出问题，以及帮助自己赢得一些设计框架所需的时间。如果实在没有条件，头铁的话，那就上吧，直接开始设计，即使失败了，也算是加一些经验吧

在需求大概了解之后，开始着手写框架之前，还需要问问自己，对于各个概念，是否理清了，是不是你和产品大佬对某个概念一起都是错误的，或者是产品大佬被你带偏了。比如说开发某些行业相关比较强的应用，是否自己理解的各个名词，各个概念，和行业里面通用理解的是相同的，有些可能混淆的概念，是否能够理清了。大部分情况下，能理清越多，那埋下的技术债务也就会越少。最怕的是存在某个概念，张冠李戴，然后还为此造了很多逻辑，而且还难以改动，那就特别闹心了。理清概念，不仅可以让自己和团队其他成员沟通起来方便，更重要的是，有很多知识可以通过搜索引擎来搜，和社区里面，如群里面的大佬们交流的时候，会更加的方便。另外计算机行业里面的编程语言，从一定的角度上也是一门语言，只要是个语言，就不可避免的存在语言的限制，描述的事物和具体期望描述的事务存在一定的偏差。特别是在框架的实现逻辑上，很多时候，所设计的数据结构和所采用的逻辑算法，将会直接影响编写的代码的方式，以及影响整个框架的设计表示。这一类问题，类似于盲人摸象的问题。我用一个小故事来方便大家理解：

在数学世界里面，有一群小人儿，这些小人儿生活在2D的欧氏平面几何世界上，这些小人儿能用来描述物体的词汇只有三角形、四方形、长方形、圆形等基础图形。当某一天小人儿们碰到来自3D世界的一个圆柱体的时候，小人儿们围了过去。挤不进里面的小人儿唧唧喳喳好奇地问着在里圈的小人儿，这是什么东西。有小人儿说，这是一个圆形；有小人儿说，这是一个长方形；也有小人儿说，这是一个不可描述的事物。在外圈的小人儿觉得很奇怪，觉得里圈的小人儿们描述起来很是自相矛盾。在小人儿的认知里面，不可能相同的一个物体同时是圆形也同时是长方形，因为这在定义上是矛盾的。在2D的欧氏平面几何世界里，能够是长方形的就一定不是圆形，反过来也是。外圈的小人儿们无法理解，其实里圈的小人儿们说的都对，只是里圈不同的小人儿的观测角度不同而已。由于观测角度不同，所见物体在2D的欧氏平面几何世界的投影也就不相同，投影出来的给小人儿们所见的几何图形也自然就不相同

其实现实世界里面也是，当人们在尝试描述一个超出认知的事情的时候，不同的人处于不同的观测角度，所见到的事物将会是不相同的，而受限于语言，描述出来的事物更是片面的。这也是盲人摸象这个成语所说的内容。在代码逻辑编写和框架设计的时候，更是如此。假定自己的知识存在盲区，就如同生活在2D的欧氏平面几何世界上的小人儿，由于认知上不存在 3D 物体，也就意味着语言上没有与此匹配的概念，对相同的事物将存在不同的表述。具体到代码设计上，那就是完成相同的一个事情，采用的设计的逻辑是片面的，而且还在一个框架里面，存在多个不同的实现逻辑都是为了解决相同的问题的不同的方面，而没有采用准确的逻辑来解决此问题。这也就是为什么我建议编程新手不要一开始就学习代码设计的原因，在对编程语言不够熟悉，对自己所使用的语言的基础设施和基础类库都还不熟悉的情况下，那自然很容易出现因为编程知识的盲区，而进行很多诡异且不合理的设计。更可怕的是，如果刚好所遇见的问题都在某一个片面的领域里面，就如同故事里面的某个小人儿对圆柱体的理解是一个圆形一样，编程新手如果一直没有跳出自己的圈子，那所见到的都如同只看到圆柱体是圆形的一面的小人儿一样，刚好将圆柱体认为是圆形，刚好问题都能解决。如此会给自己形成错误的经验，而且自己还难以知道

另外，在聊到需求的时候，可不仅仅只有产品的功能。还有一些是属于开发侧的需求点，例如比较容易被忽略的性能需求。性能需求，也是一个需求点。广义的需求是包含开发侧的需求，比如性能，比如要求后续的可维护性，比如工期等等。而这些需求之间是可能存在矛盾的，也许性能优化好的，可读性就降低，性能好又有可读性，工期又长，很多时候都难以找到完美的方案。举一个例子，有小伙伴准备在代码里面，各种地方全部都采用结构体，看起来十分奇怪。于是问他，为什么全部都采用结构体？他回答道，采用结构体的性能会更好。嗯，先抛开使用结构体是否真的能提升性能的问题，先看看他实现的需求是什么。结果发现他要做的只是一个非常边缘的模块，对性能毫无需求。于是在他的代码设计里面，为了追求性能，而大量采用结构体，他这个决策不仅让代码复杂度提升，还可能因为他对结构体理解不充分导致一些预料之外的问题。这就是属于对需求没有了解导致的设计问题。如果能提前识别此需求上，没有性能的需求，大可采用更加舒服的方式编写。不过最后我也是表扬他，因为他这是在尝试一项对于他自己来说比较新的技术。技术的尝试，放在一个可以上线的边缘的模块，可以比较好的控制风险，而且上线之后能够在真实的用户环境里面跑，了解更贴合用户运行的问题，加深他对知识的了解

开发侧的需求还包括了“什么是不该做的”的需求分析点，这也是新手常漏的，而熟练工却有高手盲区常常忘了告知新手。所谓不该做的需求，其实和“该做的”是完全一样的，准确来说就是判断一个事情该不该做的需求分析点。这个需求分析点没有一个非常客观的界定，分析的好不好取决于经验和聪慧程度。让我举个例子来告诉大家吧。有小伙伴在代码里面记录异常的逻辑里面，特意将异常信息掐头去尾，不记录异常堆栈信息，也只记录异常 Message 消息里面的一行文本，其他的全部都丢弃。一开始看到他这个代码我是比较冒火的，显然就是煞笔逻辑。但是我让自己冷静了一下，试图分析了他如此编写的出发点，以及和他沟通确认了一下。最后我发现了他居然是在想着，我的异常堆栈如果记录到日志里面，那么别人就能通过日志看到我的堆栈，这不安全。听到这个让人十分无语的理由，我才意识到，原来这位小伙伴还不懂需求分析。我反问了他一下，“你是不是在开发一个银行应用，对安全性十分有要求？”。这位小伙伴说他自己在开发一个修复工具而已。嗯，相信大家一听一看就发现好多吐槽点了。先抛开这个做法和安全性有多少关系之外，回到需求分析的角度，修复工具是否有安全性的需求，也就是做安全性是否一个“该做”的需求。其实他这个修复工具的安全性就是一个“不该做的”需求。如果有做好需求分析，了解到“安全性”是“不该做的”需求，那自然不会违背异常处理原则，写出如此令人冒火的代码。如果对调试技术有所了解，自然就不会想着记录堆栈的安全性问题。如果对安全性有所了解，自然就不会这样写。不过这里也需要补充一点的是，这位小伙伴是刚从学校出来的实习生，而且在学校里面也没有好好学过软件工程，各项基础技术和基础开发规范都还没有了解，一些软件常识也没有，这个时候请他去做开发侧的需求分析自然也是不合适的。这里引入一点新的话题，那就是做开发侧的需求分析，需要自己对技术有一点的了解，这就是本身开头所说的本身不适合新手阅读的原因之一。在新手对技术的了解是一片空白或是误解的前提下，所做的需求分析往往都是片面的或离谱的。对于产品侧的需求分析也是，如果自己缺乏相应的行业基础，那进行需求分析自然错漏的居多。技术和经验都是可以积累的，有意识的进行积累就好，减少想当然，多去了解

我大学时候学的专业是软件工程，从大学毕业后工作了许多年，我发现在软件工程上，我学完之后觉得最重要的就是 需求分析 这节课。恰好这也是当时我上软件工程时的第一节课的内容。需求分析将决定后续的开发路线，如果需求分析没做好导致开发路线错误，那后续再好的设计大部分也是白费。在开始设计之前，可以先试试拿出纸笔写写画画需求，或者打开一个文档记录自己所了解的需求。无论是拿着纸笔写写画画需求或者打开一个电子文档打打字，在写入的过程中，自己也将会有更多的考虑，或许对于原本所接到的需求有了更多细节上的了解

在每个项目完成之后，或者阶段完成时，可以来回顾一下，是否有因为自己需求分析错误，导致的后续开发或设计偏差。如果有，那就想想后续可以如何改进。改进点的思路一般就是，列举一些思考点或注意点，也就是想着如何回到当时，多思考了xx和xx或多了解多问了xx或xx是否就能规避了需求分析不当，然后将这些xx找个地方记录起来，列成列表，积累起来，下次需求分析多看看。受行业影响和个人习惯影响，每个人所记录的列表都有所不同，而且在没有经受对应的失误毒打的情况下，是难以有共同的理解的。换句话说，这个记录列表是不好抄作业的，需要自己积累



<!-- 
再给一个案例

图书馆，提升借书效率，引入自动找书机器人，抽象了人工去根据书号获取，实际是学生自己去拿书 -->


## 从减少重复代码开始

设计能力的提升可以从减少重复代码开始

稍微学过编程的伙伴都知道，重复的代码是一个技术债务。假设没有封装好的基础库，所有新功能开发都必须去找代码拷贝，而且一遇到某个问题，就要修无数的重复的代码。这无疑是在降低可维护性。而且也很难给团队带来技术的积累，即使是之前做过的功能，再次实现类似的功能，也难以快速复用之前的积累

重复的代码的抽离和封装是比较简单的事情，如果代码是完全重复的情况下，那自然是将这些重复的代码封装为一个方法，逻辑依然是能保持等价

练习的第一步就是找到重复的代码，将重复的代码抽成方法，试试换成方法调用。第二步自然就是遇到了只抽成方法无法实现的能力，例如重复的代码的使用是在多个类里面，之间的方法是不能共用的，此时就可以考虑将重复的代码从方法提升到类型。新建一个类型，包含重复的代码的封装

如此写着写着就会发现有很多帮助类和扩展辅助方法。这就是一个简单的设计的提升的开始，对完全重复的代码进行拆分，减少重复的代码

以上的练习熟练之后，就可以进行第二步，识别结构重复的代码和相似的代码，减少结构重复的代码和相似的代码的重复。我见过有很多伙伴都止步于此步，如果你还没有对此步熟练，还请不要轻易尝试后面的练习步骤，否则按照我的经验，跳过这一步的开发者写出来的“设计”的“毒”都特别大

重复的结构指的是不完全重复的代码，但是结构上是类似的，或者是代码之间是相似的，往往只是换几个变量或者更改某些执行过程。对于重复的结构的优化是需要投入一点考虑和需要一些开发经验的，因为对重复的结构“开炮”之前，是需要先了解代码的逻辑含义，否则是无法达成等价变更

刚好提到了“等价变更”这个词，需要说明一下，很多时候的优化，无论是设计上的优化还是性能上的优化，都有一个追求是优先做等价变更的更改。所谓等价变更指的是改动前后的代码逻辑上是等价的，而更加严格的指的是执行逻辑的变更是等价的。改动之前和改动之后执行的逻辑是没有变化的，有变化的只是执行过程

假设在优化的时候，能保证 `等价变更` 那就可以保证优化是不会引入新的问题，也就是不会因为优化而挖坑

在不了解业务细节的时候进行优化，特别需要注意这一点。前面的对重复的代码进行抽离，基本上都是能保持等价变更，除非自己很逗比。然而在进行重复的结构的优化的时候，如果不注意改动前后的逻辑，那确实对于新手来说，就会导致优化前后逻辑不等价，也许就挖坑了。有一个比喻我认为是很对的，前面的做对重复的代码的优化，就好像是做语文的拼音题，照着书抄能满分。而做对重复的结构的优化，就好像是做数学题，书里面只有告诉你公式，照着书抄是写不出答案的，需要自己想一下，通过公式计算

对于新手来说，优先考虑对有单元测试的项目的重复结构的代码的优化开始。单元测试一个很重要的功能就是保证逻辑的等价变更，一旦发现自己的优化导致了逻辑的不等价，单元测试也许是能立刻告诉你逻辑变更了

举个例子，假如有以下的单元测试

> 测试 Foo 方法，在输入边界的参数是 xxxxx 时，期望的返回是 xxxxxx 值

那么在进行对重复结构的代码 Foo 方法优化时，逻辑上没有保持等价改动，导致了对边界逻辑的行为的变更，那么以上的单元测试将无法通过，从而提醒开发者需要小心这里的变更

这也是侧面告诉大家，写单元测试的重要性。单元测试属于见效比较慢，但是一旦形成大量单元测试规模，那么整个项目可维护性自然也就能提升。毕竟要是在改动代码时，改代码行为了，将会有单元测试帮忙兜底。在初始尝试编写代码时，也许真的很难体会到单元测试的好处，这是因为有另一个负面的 Buffer 那就是 API 变更。对于设计新手来说，想要设计稳定的 API 是一个困难的事情，导致了 API 在开发过程不断变更，每次变更又会带来单元测试需要跟着变更的需求。在某次因为工期等原因，无法及时更新单元测试，将会形成破窗效应，渐渐单元测试就挂掉了。我无法给出一个准确的答案，对于设计新手来说，编写单元测试是否是个好事，我只能说推荐写。写了单元测试，后面又因为改 API 改 行为 需要改单元测试，这个过程，是对自己的负向反馈，也会让自己后面在设计 API 的时候，会多考虑一些，提升设计稳定 API 的能力

以上所说的 API 是广义的 API 的意思，简单说就是一切可以被外部调用的、被外部引用的成员，例如类型、方法、属性和事件等等。以及对应的 API 声明的行为，例如某个方法应该完成某件事情，或者更改哪些状态等。而破窗效应呢，这个就留给大家自行搜搜好了，这是一个有趣的故事，我可没把握将这个故事讲好，只能引用[百度百科](https://baike.baidu.com/item/%E7%A0%B4%E7%AA%97%E7%90%86%E8%AE%BA/5407392) 的原文

> 美国斯坦福大学心理学家菲利普·津巴多(Philip Zimbardo)于1969年进行了一项实验，他找来两辆一模一样的汽车，把其中的一辆停在加州帕洛阿尔托的中产阶级社区，而另一辆停在相对杂乱的纽约布朗克斯区。 [1]  他把车牌摘掉，把顶棚打开，结果记录设备都还没陈设好，停在纽约布朗克斯的跑车就已经出现第一组“破坏者”，并且想私吞这辆跑车。爸爸吩咐妈妈清理车厢，自己则动手拆电瓶，不忘提醒儿子查看置物箱。来来往往的不论开车或行走的路人，都停下来在这个拆除大赛中抢走车子上任何值钱的东西。紧接着重头戏来了，一位“破坏者”在有系统地拆卸后，成功扒走这辆置于纽约的跑车。而放在帕洛阿尔托的那一辆，人们路过、开车经过它，看着它，整整一个星期，竟然没有任何人对它“下手”。
> 以这项实验为基础，政治学家威尔逊和犯罪学家凯琳提出了一个“破窗效应”理论，认为：如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些示范性的纵容去打烂更多的窗户。久而久之，这些破窗户就给人造成一种无序的感觉，结果在这种公众麻木不仁的氛围中，犯罪就会滋生、猖獗

下面来举一个具体的代码例子告诉大家，一些简单的重复代码可以如何被消灭

例子：

以下是一段对字符串进行解析的代码，需要分别对 X 和 Y 两个方向进行分别处理，处理的方法相同。在优化重复代码的时候，大部分情况下都能做到逻辑行为等价，这时候也就不需要对代码的业务逻辑进行深入了解了

```csharp
            var xRatio = 1d;
            var yRatio = 1d;

            /* 单位一般为以下情况
             *  units="1/cm"，则比例为：ratio= 1/value unit="cm"
             */
            // 以下的 xUnit 和 yUnit 分别是字符串类型的入参
            // 以下的 xValue 和 yValue 分别也都是 double 类型的入参
            var xUnitResults = xUnit.Split('/');
            if (xUnitResults.Length == 2)
            {
                if (double.TryParse(xUnitResults[0], out var xResult))
                {
                    xRatio = xResult / xValue;
                }
            }

            var yUnitResults = yUnit.Split('/');
            if (yUnitResults.Length == 2)
            {
                //units="1/cm"
                if (double.TryParse(yUnitResults[0], out var yResult))
                {
                    yRatio = yResult / yValue;
                }
            }
```

阅读以上的代码，很简单就发现了，对于 X 和 Y 方向的处理，以上的代码是通过编写两次代码，分别对其进行处理。这样的代码看似两段逻辑不相同，实则结构是非常相同的。相信大家也很快想出来对以上代码的优化方法了

只需要对以上代码抽离出一个方法，通过这个方法里面进行统一处理即可

此章末尾还必须提醒大家，要分清需求，重复的代码是要减少而不是要消灭。不是所有的重复代码都是不好的，是否应该让代码重复，取决于需求。例如有两个程序集，逻辑关系上本来就不应该有联系，但是如果只是为了减少重复代码，强行让这两个程序集引用，只是为了调用到某些辅助函数，那无疑这是很亏的事情。不过，如果这两个程序集的重复代码是特别多，那就需要考虑一下是否再加一个程序集包含这两个程序集的重复代码，以让这两个程序集引用这个包含辅助代码的程序集，从而减少重复代码，或者是考虑将这两个程序集从逻辑上拆分但是实际上是由一个项目组建，或者是考虑通过链接引用形式引用相同的一份代码文件，或者是考虑共享项目等等。 再例如某段代码是性能敏感点，性能敏感点的代码是允许有很多破坏设计的改动以及破坏可读性的改动，这部分代码则不要放在改动考虑范围里

## 整理代码文件

日常练习里面，可以尝试着整理整理代码文件。整理代码文件包括做什么事情？可以将代码文件归类放入到文件夹和修改代码文件里面的类型的命名空间。在整理的过程中，可以更好的理解到类的职责

如果自己发现在某个文件夹里面放入了大量的类文件，那大概可以说明，这里的设计可能有优化的空间。此时可以试试看修改修改这些类文件所在的文件夹，比如自己将一个文件夹拆分为多个文件夹，比如在文件夹里面多新建几个文件夹且将类文件归类放入合适的文件夹里面。在修改类型所在的文件夹过程中，也顺手调整类型的命名空间。这里必须说明的是类型的命名空间不一定和文件夹直接对应，练习过程中不要给自己下定命名空间和文件夹必须对应的错误概念。但也推荐在整理过程中，让类型的命名空间的前面几层和文件夹嵌套以及项目程序集保持一致，这一条推荐是在保底线

大部分情况下，整理的过程中，都会发现或多或少的问题，比如说遇到了某些类型文件不知道放入到哪个文件夹里面。比如说发现自己好像没有整理的天赋，无论怎么整理类型文件，都感觉是乱糟糟的。比如说整理了之后，第二天似乎自己找不到类文件放在哪里了。比如说原本感觉逻辑自己还能理清楚的，整理了之后，差点被团队的其他伙伴拖出去揍一顿

这些事情是非常正常的。客观来说，对于一些即使本身写的就不错的类，也会因为类型本身存在多个客观概念含义，导致了可以被放入到多个不同的文件夹里面，或者是采用不同的整理角度自然会有不同的归纳类型的方式。另一方面，有一些类型由于在开发时候，没有经过设计，导致了类型包含了多个不合适放入到相同的一个类型的概念，从而导致了无论将其归类到哪个文件夹里面都不合适。或者是某些类型设计的时候包含了超过类型本身的职责，从而更加导致了整理的困难。或者是类型的不良设计导致了类型本身跨了多个设计模型的层次，导致了类文件难以放入到某一层次的文件夹里面

一般来说整理类型文件，敲黑板，我说的不是那些非定义类的文件哦，是不会导致逻辑上的变更的，可以放心在日常开发过程中整理代码文件用于练习。整理的过程中可以问问自己，凭什么这个代码文件可以放入到这个文件夹，凭什么这个文件夹是采用这样的结构进行组织，是否还有更优的方法。在整理的过程，遇到了有些代码文件难以被归类的，这时候不妨想想这个代码文件设计是否出现混乱，让一个类型耦合太多概念，或者是分层不明确

通过整理代码文件的方式，可以提升自己的熟练度，同时让自己有了一个归类的习惯。当自己写出了一个类型难以被归类的时候，自然会给自己负面的反馈，在优化类型让类型所在的代码文件可以被归类的过程，其实就是练习编写只做一件事情的类型的过程。高大上的说就是让自己在编写代码的过程将基础的单一职责设计原则不断重复练习

以上介绍的日常练习方法都是可以在不改变原有项目的逻辑上进行练习的方法。想要更进一步提升代码设计能力，就需要敢于向屎山开炮，修改破旧的代码。不过在开始修改破旧代码之前，推荐还是先使用自己准备新写的新代码进行练习，等自己的代码设计能力升级了之后再修改破旧的代码，或者是拿边缘的改坏了没人会揍你的项目来练手

## 减少编写坏代码

以上所讲的是修改已有的代码，那当轮到自己新编写的代码时，编写代码的过程可以刻意多考虑一些优化点，让自己新编写出来的代码尽量不要成为坏代码。编写出良好的代码是提升代码设计能力的重要基础。下面我将列出一些编写代码时的考虑点，期望这些考虑点可以对大家有所帮助

### 减少方法的代码行数

尽量不要让一个方法的代码太长。如果自己编写出的一个方法的代码太长了，那还请问问自己，这个方法的设计上是否合理，能否一句话描述这个方法的作用。如果无法一句话描述这个方法的作用，那就证明这个方法干了多件事情，理应拆分为多个方法。如果自己能够一句话描述这个方法的作用，那需要再思考一下，是否自己的描述可以再细分为多个步骤解决，每个步骤拆分单独的方法会让可读性更好

保持一个方法里面的代码行数不要太多是绝大部分的编程语言所推荐的原则，在 C# 语言里面同样也是推荐一个方法里面不要写太长。大部分的 C# 语言设计里面都是针对于代码行数比较少的方法友好，比如说 `using` 语句，比如说不开放只读方法参数等等，在 C# 这些语言设计里面都是基于不要让一个方法的代码太长的前提下设计的。这也是一些编程新手或者半懂不懂的开发者或民科会疑惑的点，为什么有些人用的非常顺手的，在他们手里用起来就非常不顺手。核心原因仅仅只是他们的代码充满不良设计，而大部分的编程语言都是被设计成对正常代码友好而不考虑对坏代码友好

减少一个方法的行数的通用方法一般都是拆分方法，将一个大方法拆分为多个小的方法，让每个方法都可以方便用一句话描述方法的功能

拆分方法本身是一件非常不耗费力气的活，试试看 VisualStudio 帮你一键拆分方法吧

也许大家会遇到在拆分方法的时候，对新的方法的命名困难的问题。其实这个问题也很好解决，如果拆分出来的方法可以一句话描述，那就用这句话作为方法的命名的参考即可。推荐的方法命名，在英文命名情况下就是动词开头加上名词或者宾语的形式，大概都是做某件事情的描述的命名，可选带上一些语法上的介词忽略。至于中文命名的情况下，似乎现在行业内也没有一个好的规范，我在这里也就不推荐了。无论如何，如果将一个方法拆分为用一句话可以描述，那就使用能描述方法的这句话作为方法命名的参考

### 方法参数优化

无论是拆分现有的方法还是编写代码时新写的方法，都会面临一个问题，那就是传入方法里的参数需要有哪些。按照一般用法习惯推荐是一个方法的参数是在 5 个以内，最大不要超过 16 个参数。当自己发现一个方法的参数特别多的时候，这时候可能需要回顾一下刚刚提到的减少方法的代码行数里所述的用一句话描述一个方法的用途。如果一个方法的传入参数特别多，那可能存在某个不良设计，比如方法本身干了太多的活，可能这时候方法的代码行数不多，但确实就是做了好多件事。那这时就可以考虑拆分方法，拆分之后的小方法自然就可以因为减少了方法需要干的活，从而减少需要传入的参数

另外，也许是调用方存在不良设计导致方法不得不接收多个参数。比如说存在结构相似的重复代码，没有提前拆分重复代码，导致将结构相似的重复代码带来的技术负债在方法里面偿还。同理，在方法内存在结构相似的重复代码，也没有提前拆分重复代码，导致结构重复的代码放入到相同的过程方法执行而需要过多的参数个数。这里讲得比较抽象，需要举一个例子来告诉大家。以下代码里面需要对 X 和 Y 进行分别的处理，然而 X 和 Y 的处理方法逻辑是相同的，然而以下代码选择将这些处理放入到一个方法里面

```csharp
        Calculate(x, xUnit, xOffset, y, yUnit, yOffset);

    private void Calculate(double x, double xUnit, double xOffset, double y, double yUnit, double yOffset)
    {
        if (xUnit > 0)
        {
            x *= xUnit;
        }

        if (xOffset > 0)
        {
            x += xOffset;
        }

        X = x;

        if (yUnit > 0)
        {
            y *= yUnit;
        }

        if (yOffset > 0)
        {
            y += yOffset;
        }

        Y = y;
    }

    public double X { set; get; }
    public double Y { set; get; }
```

假如有提前优化重复代码，拆分出对 X 和 Y 的通用处理逻辑，如以下代码，自然可以减少方法的参数数量

```csharp
        X = Calculate(x, xUnit, xOffset);
        Y = Calculate(y, yUnit, yOffset);

    private double Calculate(double originValue, double unit, double offset)
    {
        var result = originValue;
        if (unit > 0)
        {
            result *= unit;
        }

        if (offset > 0)
        {
            result += offset;
        }

        return result;
    }

    public double X { set; get; }
    public double Y { set; get; }
```

除了以上情况之外，一个方法的参数过多，还可能是因为对参数本身缺乏抽象设计或者是分类设计。比如说一个方法的参数本质上来说是需要有类型包起来才是合理的，然而实际实现却是拆分为多个参数逐个传入。如果这个时候定义了一个类型，使用这个类型将参数包装起来，自然就可以减少方法所需的参数。这样的设计优化常见于 Context 上下文类型传输的代码，也就是执行某个逻辑需要某个上下文参数信息，于是就将这些上下文信息包装为 Xx Context 类型，传入的是类型参数，而不是各个参数独自去传入

上文所讲的上下文只是一个广义的概念，可以理解为生活中做某个事情的所需要的信息类似的概念，比如说拧螺丝时需要螺丝等类似的情况，就可以将“螺丝”等材料，拧螺丝的“螺丝刀”工具，拧到哪里的“地方”等作为干拧螺丝这个活的上下文

什么时候应该考虑包装上下文信息？如果发现自己存在多个方法都在传递相同或者类似的参数时，就可以尝试考虑包装上下文类型。比如说自己看到了有三个方法，这三个方法所需的参数都是相同的，无论是方法定义还是实际传递的参数对象都是相同，如下面代码，那就可以开始考虑包装参数类型

```csharp
    private double Foo1(double originValue, double unit, double offset)
    {
        ...// 忽略代码
    }

    private double Foo2(double originValue, double unit, double offset)
    {
        ...// 忽略代码
    }

    private double Foo3(double originValue, double unit, double offset)
    {
        ...// 忽略代码
    }
```

以下是包装了参数的类型之后的代码情况，一般的包装类型都是叫 Xx Context 或者是 Xx Argument 类型。我对于纯参数类型的，或者是用于放入到事件传递的，都是命名为 Xx Argument 类型。而遇到需要进行传输的，有明确的请求响应的，那就包装为 Xx Request 或者是 Xx Response 类型

```csharp
    readonly record struct XxArgument(double OriginValue, double Unit, double Offset);

    private double Foo1(in XxArgument argument)
    {
        ...// 忽略代码
    }

    private double Foo2(in XxArgument argument)
    {
        ...// 忽略代码
    }

    private double Foo3(in XxArgument argument)
    {
        ...// 忽略代码
    }
```

无论是包装 Argument 类型还是包装上下文信息，除了用在减少方法参数的情况下，还可以用在设计过程中 API 不稳定的时候的优化，减少重复的工作量。还是以上的例子，假如以上的三个方法在设计的过程中想要变更参数，比如说多加一个参数，在没有包装参数类型之前，需要逐个方法签名进行变更，加上新的参数。而在有包装的参数类型之后，只需要改动包装的参数类型加上一个参数即可。但必须说明的是，不能采用包装 Argument 类型或包装 Context 上下文信息的方式来掩盖设计上的缺陷，一般来说在最终设计完成之后，除了编写框架逻辑之外，业务层的参数应该是固化下来，如果定义包装类型只是为了不去设计具体应该有哪些参数，那这是不合理的

一旦定义包装类型，需要额外思考的问题是包装类型是否包含过多内容，是否存在公开了不应该公开的信息，是否对传入的模块包含了太多模块里不应该关心的信息。比如说自己定义了一个超大的包装类型，这个包装类型包含了应用程序的所有信息。那这个时候还请思考一下，这和直接全局全部静态有什么差别。包装类型的时候一个原则是尽可能只包含必要的信息，如果是对外返回的类型则再考虑是否包含了不适合公开的信息

制作包装类型的过程中也可以顺带锻炼自己思考如何封装一个类型，以下是我列出的开发过程中的思考点，这些思考点不仅可以用在包装类型的设计上，也可以用在其他业务逻辑上，设置是框架设计上

### 减少类型的成员

<!-- 问问自己是否应该放入到这里 -->

## 试试设置可访问性级别

考虑可测试

考虑容错

考虑调用方便

写代码前先给点时间



降低逻辑复杂度 考虑扩展性，但是不要过多考虑扩展性 在需求不明确的时候

再需要明确一点，在设计上，是没有不可以或者不可能这句话的。唯一有不可以和不可能的，只有底层组件。设计上，一个绝对完美的方案也是存在的，只是在于人类能不能想到而已。但好在绝大部分情况下，要求都没有那么完美，在符合一定条件下的完美方案是存在的。如果想要提升自己的设计能力，就要少说不可以和不可能，试试设计一下，各个方面都能兼顾是可以实现的。将目标定高一些，即使最后不能完成，一般结果都不会太差

很多时候都需要对自己所拿到的需求进行加工，不一定逻辑上是如何就完全跟着逻辑走。完全跟着逻辑顺着走的方式叫平推，这个方式优点在于理解顺序和逻辑顺序相关，缺点在于复杂度可能上来的时候超级复杂。如果是平推的方法，可以用一个例子说明，如果做某个事情有三步，第一步有三个可能，第二步有三个可能，第三步有三个可能，按照顺序逻辑就是有 27 个分支逻辑，那如果再加一步呢。很快逻辑的复杂度就上来额


设计也是开发的一个部分，是需要投入时间和精力的。很多时候我都无法立刻给出一个小模块的框架的设计，都需要进行思考，或者进行尝试才能知道。在开始进入写代码之前，先刻意让自己等一下，想想设计，也是一个提升的方式。但是有一点必须说明的是，和具体的人有关，有些人的设计是需要拿出纸写的，而有些人是必须敲代码进行设计的，例如我就不喜欢写和画设计图，而是喜欢写一些代码，这时候的写代码可不能强行算是写代码哦，这只是一个进行设计的过程。在写代码之前，先让自己停下来，更多指的是让自己去思考一下代码的设计，至于设计时的方式，喜欢用笔写还是喜欢敲代码那就看你的心情


## 拍解决方案之前先问问自己

在决策时，准备拍下某个问题的解决方案时，可以先强制自己冷静一下，再思考一下，问问自己，是否这样的解决方法是足够的，考虑充分的，是否因为过程中存在很多干扰，导致路子歪了。在我所见到的很多伙伴告诉我的解决方案里面，发现了如果是新手工程师，告诉我的解决方案，很多时候我都需要习惯的问一句，这个问题的本质是什么呢。因为很多时候给出的解决方案，处理的是都是 X-Y 问题。所谓 X-Y 问题，粗略来说就是发现了 X 问题，为了解决 X 问题，提出了 Y 方案，结果 Y 方案又存在问题，继续解决 Y 方案的问题。也就是说很多新手工程师，经常决策出来的解决方案都不是围绕实际问题本身，而是被处理，被加工之后的问题。这个处理可能是上下游给处理的，例如新手工程师的技术经理，例如新手工程师的产品经理，甚至是群里的伙伴们。我反过来思考，其实当年我也是如此，我有一次设计了一个自己认为非常妙的方案，去告诉我师傅。结果我花了快一天的时间，才将这个方案和我师傅讲清楚。最后我师傅花了更长时间似乎懂了这个我的解决方案，然后哭笑不得告诉我，其实我这个方案是因为我要解决的问题，距离我实际遇到的问题太过于远，才这么复杂的。然后我师傅就和我聊了一会，基于我的本质问题，给出了一个特别简单的解决方案，甚至连方案就不能算上，只需要几句代码就完成了。为了解决 X 问题，提出 Y 方案，为了完善 Y 方案的漏洞，提出了 Z 方案… 不断叠加，最后的解决方案特别复杂，但其实想想，都是在做 Y 方案的各种补丁而已。在做决策之前，问问自己，是不是自己决定的解决方案处理的都不是在直接处理本质问题的

当时我设计的那个方案和遇到的问题，和我所在的业务太强相关了，就不合适写在博客里面。不过我找到一个小故事，倒是能很好说明。从前，有一个大聪明，他准备拿着骑着毛驴，带着一袋货物准备去集市。当他走到半路的时候，发现货物太重了，毛驴有些走不动。于是大聪明想到了帮助毛驴减轻负担的方法，他将货物背起来。他想着这样子毛驴就不要背着货物了，而是又着他背着货物。又走了一会儿，大聪明自己背得很累，可毛驴彻底走不动了。 这个故事很多小朋友都听过，然而现实开发里面，我也经常遇到类似的设计决策，只不过现实的问题会更加复杂且前置知识不见得一定能知道。读过书的伙伴都知道，毛驴背上的重量，一直都是等于大聪明的重量加上货物的重量。至于大聪明是否将货物背上，对毛驴来说，关系不大，只是能感动大聪明自己而已。咱现在能够嘲笑大聪明，这是因为咱知道现实的基础知识，但是换成更加复杂的编程问题的时候，可不见得咱能够知道足够的基础知识，而且即使了解过这部分基础知识，也不见得能够反应过来。在进行设计方案的决策之前，如果发现自己对于准备要进行的开发的需求，依然存在一些谜团，此时就需要先警惕一下，我现在这个设计方案，会不会只是一个用来感动自己，而是毫无作用的设计方案，我之所以会如此决策，只是因为我少了解了某些事情。延伸过来的，一个人是很难对现代如此庞大的计算机相关的知识进行全面的了解，甚至咱很多开发也会面向某些特定的行业，这也就让一个人的知识面必然存在某些盲区。但是如果有一个团队，那就能很好的补足这部分的问题，这也就是技术评审本身能带来的价值。我和某些不喜欢技术评审的伙伴聊过，他们提到的技术评审的不喜欢的理由在于，技术评审很像是在找茬和质疑，体验很差。这其实和团队的文化有关，很难强求，我认为一个正常的团队，技术评审需要整个团队达成一致，技术评审是用来帮助全面思考，相互补位的过程，而不是一个对立的事情。如果所在的团队没有能很好的实现这一点，也许可以找找几个信得过的伙伴，私下聊一聊。不涉及公司具体业务的情况下，在网上聊一聊也可以

提到了将自己的设计方案聊一聊的事情，也不得不讲到小黄鸭的故事。刚才提到的破窗效应是属于被咱计算机行业拿过来用的，那现在提到的小黄鸭的故事就是咱计算机行业所创的一个有趣的故事，且现在也不限于计算机行业在使用。一句话介绍小黄鸭的故事，小黄鸭的故事，起始是有大佬随身带着一只小黄鸭玩具，每当他需要调试时候，就会找这只小黄鸭聊聊天，聊着聊着他就自然将问题解决了，这就是计算机行业里有名的小黄鸭调试法。不要看这个小黄鸭调试法听起来十分奇怪，现实里面，这是非常有用的方法，不信的话，去网上搜搜看看大佬们的故事。不单只是在调试时可以用到小黄鸭，其实在设计方案的时候，也合适找小黄鸭聊聊天。我感觉，在找小黄鸭聊聊天之前，也许我的设计方案里面是存在某些我以为逻辑上是通的，但实际上存在明显缺陷的地方，和小黄鸭聊天，将我的设计方案，可以让我重新梳理一下思路，可以找到很多之前没有考虑到的，甚至是聊着我就想到更好的方法。另一方面，有一些设计方案是需要进行团队协作的，团队协作就需要让组员理解此设计方案，提前自己先找小黄鸭聊聊天，相当于试讲，可以在后续找组员同步信息的时候，更加有条理，也让组员更好理解。当然了，聊天的对象也不局限于小黄鸭这个物种，你可以开心的找小猫小狗，甚至是团队里面的小伙伴们聊聊


## 储藏知识

在写的时候，多思考。思考是需要有知识作为支撑的，而知识也分为很多方面。例如通过实验发现了奇数的问题，看到垃圾博客写的奇数问题，实际需要了解规则

<!-- 思考 求奇数问题

找到度量值：如做饭的时候决定下多少菜，用的度量是钱，下一块钱的菜。菜价是会波动的，在自己现在做菜的时候是对的，但也许很快就凉凉

-->


## 给自己一点小要求

如果有遇到设计的代码是可以作为框架的情况，可以适当给自己一点小要求，可以试试以下的列表，将以下列表作为自己的设计的代码的要求

- 方便扩展： 能否在新加功能的时候，不改动或者少改动之前的代码和机制
- 方便静态阅读： 是否在不运行和没在 Visual Studio 的帮助下，也能阅读部分代码，特别是入口的 API 层
- 方便调试： 如果使用过程存在问题，是否很方便提供调试。或者是在使用有误时，及时给出明确错误
- 对 API 进行分层：简单的常用的 API 放在比较好调用的一层，高级的使用方法和带坑的 API 放在比较深的层
- 遵守默认约定：是否自己新写的代码和 dotnet 官方框架或者现有的项目的其他模块的设计十分背离
- 统一性设计：自己的各个模块，模块和模块之间，以及自己和 dotnet 官方框架或现有项目的其他模块之间，是否存在统一性，是不是自己新写的代码是在造自己独立的概念
- 不同的逻辑截然不同：如果有相似但完全不相同的概念，是否会造成其他开发者混淆，有没有让不同的逻辑看起来截然不同
- 开发时做好防逗比：有没有防止其他开发者或者以后的自己进行逗比调用，是否在进行逗比调用时给出明确的提示


以上要求的更多细节，还请参阅 [框架设计的想法](https://blog.lindexi.com/post/%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%83%B3%E6%B3%95.html )


<!-- ## 多找茬

回过头看自己的设计，给自己找茬。遇到问题，先想想是不是自己设计的问题 -->

<!-- 

我见到过许多高阶的工程师，其中不乏一些我给他的成就打上

 -->




<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。欢迎转载、使用、重新发布，但务必保留文章署名[林德熙](http://blog.csdn.net/lindexi_gd)(包含链接:http://blog.csdn.net/lindexi_gd )，不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我[联系](mailto:lindexi_gd@163.com)。